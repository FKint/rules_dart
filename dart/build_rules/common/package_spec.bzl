"""Dart rules for building package specs."""

load(
    "//dart/build_rules/common:path.bzl",
    _relative_path = "relative_path",
)
load(
    "//dart/build_rules/common:context.bzl",
    _collect_dart_context = "collect_dart_context",
    _make_dart_context = "make_dart_context",
)

def _dart_package_spec_impl(ctx):
    dart_deps = [dep for dep in ctx.attr.deps if hasattr(dep, "dart")]
    dart_ctx = _make_dart_context(ctx, deps = dart_deps)

    additional_dart_ctx = None
    if ctx.attr.additional_deps:
        additional_dart_deps = [dep for dep in ctx.attr.additional_deps if hasattr(dep, "dart")]
        additional_dart_ctx = _make_dart_context(ctx, deps = additional_dart_deps)

    package_spec_action(
        ctx,
        dart_ctx,
        ctx.outputs.package_spec,
        use_relative_path = ctx.attr.use_relative_path,
        additional_ctx = additional_dart_ctx,
    )
    return struct(
        runfiles = ctx.runfiles([ctx.outputs.package_spec]),
    )

_dart_package_spec_attrs = {
    "deps": attr.label_list(
        mandatory = True,
    ),
    "additional_deps": attr.label_list(),
    "use_relative_path": attr.bool(default = True),
}

dart_package_spec = rule(
    attrs = _dart_package_spec_attrs,
    outputs = {
        "package_spec": "%{name}.package_spec",
    },
    implementation = _dart_package_spec_impl,
)

def package_spec_action(
        ctx,
        dart_ctx,
        output,
        relative_package = None,
        use_relative_path = True,
        additional_ctx = None):
    """Generates a Dart package spec.

    Args:
      ctx: The rule context.
      dart_ctx: The Dart context.
      output: The output package_spec file.
      relative_package: Package to make paths relative to (defaults to dart_ctx.label.package).
      use_relative_path: Resolve resources relative to the path of the package spec file.
      additional_ctx: Additional dart context to use for package resolution e.g. a test_runner dart ctx.
    """

    # There's a 1-to-many relationship between packages and targets, but
    # collect_transitive_packages() asserts that their lib_roots are the same.
    dart_ctxs = _collect_dart_context(dart_ctx).values()

    if additional_ctx:
        additional_ctxs = _collect_dart_context(additional_ctx).values()
        dart_ctxs = dart_ctxs + additional_ctxs

    content_dict = {}
    if not relative_package:
        relative_package = dart_ctx.label.package

    for dc in dart_ctxs:
        if use_relative_path:
            relative_lib_root = _relative_path(relative_package, dc.lib_root)
            content_dict[dc.package] = relative_lib_root
        else:
            content_dict[dc.package] = dc.lib_root

    content = "# Generated by Bazel\n"
    for package, path in content_dict.items():
        content += "%s:%s\n" % (package, path)

    # Emit the package spec.
    ctx.actions.write(
        output = output,
        content = content,
    )
